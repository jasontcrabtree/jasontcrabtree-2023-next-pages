---
date: 2024-05-02
description: ''
title: ''
# type: 'blog-post'
---

# Harvard CS50x 2024: Lecture 2 - Arrays

Completed May 2024

[CS50x 2024 - Lecture 2 - Arrays](https://www.youtube.com/watch?v=4vU4aEFmTSo&t=945s&ab_channel=CS50) - by David Malan

## Table of Contents

### General Notes

- Demo where students read at 3 different grade levels, year 1, 3 and 10 to highlight the differences of each level and how building blocks form and get more advanced over time
- Discussion about compiling and how the `make` program we have been running isn't native C functionality, but instead a program that simplifies compiling our code.

## Breaking down compiling into its individual steps: Preprocessing, Compiling

- Note about prototypes and the purpose they have in code files

```
void meow(void);

int main(void)
{
    printf("Hello world\n");
}

void meow(void)
{
    printf("Meow meow\n");
}
```

#### Preprocessing

- Preproccesor directive: # symbol indicates to c a special line, in most cases referencing a header file. In the case of referencing `#include <cs50.h>`, we are telling c that as part of preprocessing this file, and when it finds that file it copies and pastes the contents of the file for your own code to use.
- The actual cs50 file includes **prototypes** for all of the available functions, not the entire function.
- Preprocessing converts # include files to be available directly in your code

#### Compiling

- Converting the source code you have written (including any includes, etc) into assembly code

#### Assembling

- Converts assembly code into machine code (0s/1s)

#### Linking

- To understand linking we have to understand that in addition to the include prototypes, somewhere on the machine (the compiler is running on) there is an actual .c file with the function specified in the prototype. So somewhere on the vscode cloud implementation for the class, there is a file named `cs50.c`, which includes a prototype to the file named `get_string.c`, which includes our function `get_string()`
- Linking brings these files all together, using clang (c-lang), our compiler. While the compiler now has all machine code as 3 different clumps, the final step is to combine them together to be available as one single, compiled file

- Because you can compile code into machine code, it makes sense to think that you could convert machine code back into source code. This creates problems when you look at intellectual property like Microsoft Word.
- Reverse engineering is harder than it seems as there can be multiple ways to solve problems. There's not always an obvious way to reverse the machine code and determine the actual way it was built, as loops, variable names, function names all become unreadable
- This leads to an idea where if you are experienced enough to reverse engineer a c program, you could probably write it yourself

## Debugging

- Rare to write new code correct the first time, bugs are inevitable writing software
- Admiral Grace Hopper (Military/Harvard) worked on the Harvard Mark I, Harvard Mark II, and the team found a bug in the punch card program, which she shared and told into legend
- Debugging techniques
  - `printf` lets you see what is happening in your program
  - **debugger**: industry tool to debug programs. We'll start the example using a cs50 specific debugger.
  - Debuggers need code to be compiled, they don't help with syntax, but instead help with logic and programmatic files
  - `debug50 ./buggy` to run the program used the debugger program
  - First warning informs the user to set a breakpoint, indicating where to pause the program. This can be achieved in VSCode by hovering to the left of the line number and setting a red circle breakpoint
  - This informs the debugger to pause execution on that line
  - This shows a breakdown of the program, seperating into: variables (locals/registers), watch section, call stack, and the program itself -- highlighted where the program has paused.
  - You can then step into the line your program is paused into, or step down to new lines (expand function or step over function)
  - Step over === execute the step and go to next
  - Step into === execute the step and focus on it
    - Jumps to the actual code being run on the line (e.g. a function call, shows the function)
    - Good example of this would be calling a function inside a loop, seeing each call of that function (e.g. printf a #), and then seeing how many times that function is called
  - Can be easy to defaulting to using printf, but over time actually using debuggers (and learning their functionality) will pay dividends over time
  - Rubber duck debugging - **talking outloud** can help you catch problems in how you are thinking about a problem or solution
  - cs50.ai is a Harvard LLM implementation

## Data Types

- Informing the computer of the context of variables, helping them determine whether bits mean colour, sound, text or images

### Data type sizes

- bool 1 byte
- int 4 bytes
- long 8 bytes
- float 4 bytes
- double 8 bytes
- char 1 byte
- string ? bytes

### Circuit board

A circuit board holds your RAM, Random Access Memory (typically the black chip on your circuit board). Image this is abstracted to a grid visually on top of the chip. You could image that each square, e.g. A3 (excel layout) represents a different byte, e.g. a bool.

No matter how complex the modern computer, ultimately it all drops down to the lowest level of the computer stack of bytes, represented by 1s and 0s.

#### Demo score.c program

```
#include <stdio.h>

int main(void)
{
    int score1 = 72;
    int score2 = 73;
    int score3 = 3;

    // Introduces a bug, as we are averaging ints, not floats
    // printf("Average: %f\n", (score1 + score2 + score3) / 3); v1
    printf("Average: %f\n", (score1 + score2 + score3) / 3.0); // v2
}
```

Math operations on integers will always return integers. If you have one float involved in the math, the result will be a float, so we can fix this by adding a decimal.

We can display each score on our theoretical circuit board memory, like so. In practice, data is probably stored next to related data.

![./public/assets/cs50/4-squares-per-integer.png](4 Squares per integer)

![./public/assets/cs50/scores-in-machine-code.png](We can see the same scores expressed as machine code)

While this approach does get us to the correct average, from a programming perspective we have created new variables for every single score. As more scores are added, we need to create more and more variables. Instead, we can use an array.

An array is a sequence of values back to back to back in a chunk of memory, with no gaps or fragmentation.

Defining an array `int scores[3];` lets use create 3 variables. We need to tell the compiler how much room is needed from the start.

We can then assign values via:

```
scores[0] = 72;
scores[1] = 73;
scores[2] = 33;
```

#### Updating our score.c program

```
#include <cs50.h>
#include <stdio.h>

int main(void)
{
  int scores[3];
  scores[0] = get_int("Score: ");
  scores[1] = get_int("Score: ");
  scores[2] = get_int("Score: ");

  printf(:"Average: %f\n", (scores[0] + scores[1] + scores[2]) / 3.0);
}
```
